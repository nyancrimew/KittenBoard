use std::f32::consts::PI;

pub const NOT_A_DISTANCE_FLOAT: f32 = -1.0;
pub const MIN_DOUBLE_LETTER_BEELINE_SPEED_PERCENTILE: i32 = 5;
pub const VERTICAL_SWEET_SPOT_SCALE: f32 = 1.0;
pub const VERTICAL_SWEET_SPOT_SCALE_G: f32 = 0.5;

pub const NEAR_KEY_THRESHOLD_FOR_DISTANCE: f32 = 2.0;

pub const MARGIN_FOR_PREV_LOCAL_MIN: f32 = 0.01;

pub const DISTANCE_BASE_SCALE: i32 = 100;
pub const NEAR_KEY_THRESHOLD_FOR_POINT_SCORE: f32 = 0.6;
pub const CORNER_CHECK_DISTANCE_THRESHOLD_SCALE: i32 = 25;
pub const NOT_LOCALMIN_DISTANCE_SCORE: f32 = -1.0;
pub const LOCALMIN_DISTANCE_AND_NEAR_TO_KEY_SCORE: f32 = 1.0;
pub const CORNER_ANGLE_THRESHOLD_FOR_POINT_SCORE: f32 = PI * 2.0 / 3.0;
pub const CORNER_SUM_ANGLE_THRESHOLD: f32 = PI / 4.0;
pub const CORNER_SCORE: f32 = 1.0;

pub const NUM_POINTS_FOR_SPEED_CALCULATION: usize = 2;

pub const LAST_POINT_SKIP_DISTANCE_SCALE: i32 = 4;

pub const LOOKUP_RADIUS_PERCENTILE: i32 = 50;
pub const FIRST_POINT_TIME_OFFSET_MILLIS: i32 = 150;
pub const STRONG_DOUBLE_LETTER_TIME_MILLIS: i32 = 600;

pub const MIN_PROBABILITY: f32 = 0.000005;
pub const MAX_SKIP_PROBABILITY: f32 = 0.95;
pub const SKIP_FIRST_POINT_PROBABILITY: f32 = 0.01;
pub const SKIP_LAST_POINT_PROBABILITY: f32 = 0.1;
pub const MIN_SPEED_RATE_FOR_SKIP_PROBABILITY: f32 = 0.15;
pub const SPEED_WEIGHT_FOR_SKIP_PROBABILITY: f32 = 0.9;
pub const SLOW_STRAIGHT_WEIGHT_FOR_SKIP_PROBABILITY: f32 = 0.6;
pub const NEAREST_DISTANCE_WEIGHT: f32 = 0.5;
pub const NEAREST_DISTANCE_BIAS: f32 = 0.5;
pub const NEAREST_DISTANCE_WEIGHT_FOR_LAST: f32 = 0.6;
pub const NEAREST_DISTANCE_BIAS_FOR_LAST: f32 = 0.4;
pub const ANGLE_WEIGHT: f32 = 0.90;
pub const DEEP_CORNER_ANGLE_THRESHOLD: f32 = PI * 60.0 / 180.0;
pub const SKIP_DEEP_CORNER_PROBABILITY: f32 = 0.1;
pub const CORNER_ANGLE_THRESHOLD: f32 = PI * 30.0 / 180.0;
pub const STRAIGHT_ANGLE_THRESHOLD: f32 = PI * 15.0 / 180.0;
pub const SKIP_CORNER_PROBABILITY: f32 = 0.4;
pub const SPEED_MARGIN: f32 = 0.1;
pub const CENTER_VALUE_OF_NORMALIZED_DISTRIBUTION: f32 = 0.0;
// TODO: The variance is critical for accuracy; thus, adjusting these parameters by machine
// learning or something would be efficient.
pub const SPEEDxANGLE_WEIGHT_FOR_STANDARD_DEVIATION: f32 = 0.3;
pub const MAX_SPEEDxANGLE_RATE_FOR_STANDARD_DEVIATION: f32 = 0.25;
pub const SPEEDxNEAREST_WEIGHT_FOR_STANDARD_DEVIATION: f32 = 0.5;
pub const MAX_SPEEDxNEAREST_RATE_FOR_STANDARD_DEVIATION: f32 = 0.15;
pub const MIN_STANDARD_DEVIATION: f32 = 0.37;
pub const STANDARD_DEVIATION_X_WEIGHT_FOR_FIRST: f32 = 1.25;
pub const STANDARD_DEVIATION_Y_WEIGHT_FOR_FIRST: f32 = 0.85;
pub const STANDARD_DEVIATION_X_WEIGHT_FOR_LAST: f32 = 1.4;
pub const STANDARD_DEVIATION_Y_WEIGHT_FOR_LAST: f32 = 0.95;
pub const STANDARD_DEVIATION_X_WEIGHT: f32 = 1.1;
pub const STANDARD_DEVIATION_Y_WEIGHT: f32 = 0.95;

// TODO: add the rest when we get to them
